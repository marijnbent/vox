This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
assets/
  main.css
  widget.css
components/
  layout/
    AppLayout.svelte
    StatusIndicator.svelte
  settings/
    Dashboard.svelte
    Dictionary.svelte
    Enhancements.svelte
    History.svelte
    Logs.svelte
    Permissions.svelte
    Shortcuts.svelte
    Transcription.svelte
  WaterWaveAnimation.svelte
lib/
  audioRecorder.ts
App.svelte
env.d.ts
main.ts
widget.ts
WidgetApp.svelte

================================================================
Files
================================================================

================
File: assets/main.css
================
@import 'remixicon/fonts/remixicon.css';

body, html {
  user-select: none;
}

input,
textarea {
  user-select: text;
}
@import "tailwindcss";

@plugin "daisyui" {
  themes: caramellatte --default;
}

:root[data-theme="caramellatte"] {
  background-color: transparent;
}

================
File: assets/widget.css
================
@import 'remixicon/fonts/remixicon.css';

/* Disable text selection globally for a more native app feel */
body, html {
  -webkit-user-select: none; /* Safari */
  -ms-user-select: none; /* IE 10 and IE 11 */
  user-select: none; /* Standard syntax */
}

@import "tailwindcss";

================
File: components/layout/AppLayout.svelte
================
<script lang="ts">
  import StatusIndicator from './StatusIndicator.svelte';

  export let activePage = 'dashboard';

  const navItems = [
    { id: 'dashboard', label: 'Dashboard', icon: 'dashboard-3' },
    { id: 'shortcuts', label: 'Shortcuts', icon: 'command' },
    { id: 'transcription', label: 'Transcription', icon: 'mic' },
    { id: 'enhancements', label: 'Enhancements', icon: 'sparkling' },
    { id: 'dictionary', label: 'Dictionary', icon: 'book' },
    { id: 'permissions', label: 'Permissions', icon: 'shield-check' },
    { id: 'history', label: 'History', icon: 'time' },
    { id: 'logs', label: 'Logs', icon: 'file-warning' },
  ];
</script>

<div class="flex min-h-screen">
  <aside class="bg-base-200 w-64 h-screen flex flex-col sticky top-0">
    <div class="px-4 py-6">
      <h1 class="text-2xl font-bold">ðŸŽ¤âœ¨</h1>
    </div>

    <ul class="menu menu-lg p-2 pt-0 flex-1 overflow-y-auto">
      {#each navItems as item}
        <li>
          <a
            href="#{item.id}"
            class="{activePage === item.id ? 'active' : ''}"
            on:click={(): void => { activePage = item.id; }}
          >
            <span class="flex items-center text-base">
              <i class="ri-{item.icon}-line mr-3"></i>
              {item.label}
            </span>
          </a>
        </li>
      {/each}
    </ul>

    <div class="mt-auto mb-0">
      <StatusIndicator />
    </div>

    <div class="p-4 text-xs opacity-70">
      <p>Vox Transcriber v1.0.0</p>
    </div>
  </aside>

  <main class="flex-1 overflow-y-auto">
    <div class="p-4 md:p-6">
      <slot />
    </div>
  </main>
</div>

================
File: components/layout/StatusIndicator.svelte
================
<script lang="ts">
  import { recordingStatus, transcriptionResult, transcriptionError } from '../../lib/audioRecorder';
  import { onDestroy } from 'svelte';

  let statusText = 'Ready';
  let iconClass = 'ri-mic-line'; // Default icon
  let indicatorClass = 'bg-base-content/20'; // Default background
  let showResultTimeout: NodeJS.Timeout | null = null;

  const statusUnsubscribe = recordingStatus.subscribe(status => {
    clearTimeoutIfActive();
    switch (status) {
      case 'recording':
        statusText = 'Recording';
        iconClass = 'ri-record-circle-fill text-error animate-pulse'; // Pulsing red circle
        indicatorClass = 'bg-error/20';
        break;
      case 'processing':
        statusText = 'Processing';
        iconClass = 'ri-loader-4-line animate-spin'; // Spinner
        indicatorClass = 'bg-info/20';
        break;
      case 'error':
        statusText = $transcriptionError || 'Error'; // Show specific error if available
        iconClass = 'ri-error-warning-fill text-error'; // Error icon
        indicatorClass = 'bg-error/20';
        // Keep error visible for a while
        showResultTimeout = setTimeout(() => {
            if ($recordingStatus === 'error') { // Only reset if still in error state
                 recordingStatus.set('idle'); // Reset to idle after timeout
            }
        }, 5000);
        break;
      case 'idle':
      default:
        // Check if there's a recent result or error to display briefly
        if ($transcriptionResult) {
            statusText = 'Done';
            iconClass = 'ri-check-line text-success'; // Checkmark
            indicatorClass = 'bg-success/20';
            // Show result briefly then return to idle
            showResultTimeout = setTimeout(() => {
                 if ($recordingStatus === 'idle') { // Avoid race conditions
                    resetToIdle();
                 }
            }, 3000);
        } else {
             resetToIdle(); // Go directly to idle if no result/error
        }
        break;
    }
  });

  // Also watch transcriptionResult and transcriptionError directly
  // in case they update while status is already 'idle' (e.g., paste error)
  const resultUnsubscribe = transcriptionResult.subscribe(result => {
      if (result && $recordingStatus === 'idle') {
          clearTimeoutIfActive();
          statusText = 'Done';
          iconClass = 'ri-check-line text-success';
          indicatorClass = 'bg-success/20';
          showResultTimeout = setTimeout(resetToIdle, 3000);
      }
  });

  const errorUnsubscribe = transcriptionError.subscribe(error => {
      if (error && $recordingStatus !== 'error') { // Don't override if already in error state
          clearTimeoutIfActive();
          statusText = error;
          iconClass = 'ri-error-warning-fill text-error';
          indicatorClass = 'bg-error/20';
          showResultTimeout = setTimeout(() => {
              if ($recordingStatus !== 'recording' && $recordingStatus !== 'processing') {
                  recordingStatus.set('idle'); // Reset only if not actively recording/processing
              }
          }, 5000);
      }
  });


  function resetToIdle() {
      statusText = 'Ready';
      iconClass = 'ri-mic-line';
      indicatorClass = 'bg-base-content/20';
      // Clear results/errors from stores when truly idle? Optional.
      // transcriptionResult.set(null);
      // transcriptionError.set(null);
  }

  function clearTimeoutIfActive() {
      if (showResultTimeout) {
          clearTimeout(showResultTimeout);
          showResultTimeout = null;
      }
  }

  onDestroy(() => {
    statusUnsubscribe();
    resultUnsubscribe();
    errorUnsubscribe();
    clearTimeoutIfActive();
  });

</script>

<div class="px-4 py-2 mb-2 flex items-center space-x-2 rounded-md {indicatorClass}">
  <i class="{iconClass} text-lg"></i>
  <span class="text-sm font-medium truncate" title={$transcriptionError ?? statusText}>
    {statusText}
  </span>
</div>

================
File: components/settings/Dashboard.svelte
================
<script lang="ts">
  // Removed incorrect store import

  // Status is usually managed by the main process
  let status = {
    isRecording: false,
    isInitialized: true,
    transcriptionBackend: "Local Whisper",
    enhancementEnabled: false,
    lastTranscription: null as string | null
  };

  // Example transcriptions for demo
  const recentTranscriptions = [
    { text: "This is a test transcription to demonstrate the UI.", timestamp: Date.now() - 60000, enhanced: false },
    { text: "Vox transcriber is designed to help you convert speech to text quickly.", timestamp: Date.now() - 600000, enhanced: true }
  ];
</script>

<div class="p-4">
  <h2 class="text-2xl font-bold mb-6">Dashboard</h2>
  
  <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
    <!-- Status Card -->
    <div class="card bg-base-100 shadow-md">
      <div class="card-body">
        <h3 class="card-title">System Status</h3>

        <div class="divider my-1"></div>
        
        <div class="grid grid-cols-2 gap-2">
          <div class="font-semibold">Recording:</div>
          <div class="flex items-center">
            <span class="{status.isRecording ? 'bg-red-500' : 'bg-gray-400'} rounded-full w-2 h-2 mr-2"></span>
            {status.isRecording ? 'Active' : 'Inactive'}
          </div>
          
          <div class="font-semibold">Whisper Engine:</div>
          <div class="flex items-center">
            <span class="{status.isInitialized ? 'bg-green-500' : 'bg-yellow-500'} rounded-full w-2 h-2 mr-2"></span>
            {status.isInitialized ? 'Ready' : 'Initializing...'}
          </div>
          
          <div class="font-semibold">Backend:</div>
          <div>{status.transcriptionBackend}</div>
          
          <div class="font-semibold">Enhancement:</div>
          <div>{status.enhancementEnabled ? 'Enabled' : 'Disabled'}</div>
        </div>
      </div>
    </div>
    
    <!-- Shortcuts Card -->
    <div class="card bg-base-100 shadow-md">
      <div class="card-body">
        <h3 class="card-title">Quick Actions</h3>
        <div class="divider my-1"></div>
        
        <div class="flex flex-col gap-3">
          <button class="btn btn-primary">Test Microphone</button>
          <button class="btn btn-secondary">Test Transcription</button>
          <button class="btn">Configure Permissions</button>
        </div>
      </div>
    </div>
    
    <!-- Recent Transcriptions -->
    <div class="card bg-base-100 shadow-md md:col-span-2">
      <div class="card-body">
        <h3 class="card-title">Recent Transcriptions</h3>
        <div class="divider my-1"></div>
        
        {#if recentTranscriptions.length > 0}
          <div class="flex flex-col gap-4">
            {#each recentTranscriptions as transcription}
              <div class="bg-base-200 p-3 rounded-lg">
                <p class="text-sm mb-2">{new Date(transcription.timestamp).toLocaleString()}</p>
                <p class="text-lg">{transcription.text}</p>
                {#if transcription.enhanced}
                  <span class="badge badge-accent mt-2">Enhanced</span>
                {/if}
              </div>
            {/each}
          </div>
        {:else}
          <p class="text-center py-4 text-base-content/70">No recent transcriptions</p>
        {/if}
        
        <div class="card-actions justify-end mt-2">
          <a href="#history" class="btn btn-sm btn-outline">View All History</a>
        </div>
      </div>
    </div>
  </div>
</div>

================
File: components/settings/Dictionary.svelte
================
<script lang="ts">
  import { onMount, tick } from 'svelte'; // Add tick
  import { writable, get } from 'svelte/store'; // Import writable/get

  // Define the type locally or import from a shared types file if available
  interface DictionarySettings {
    words: string[];
  }

  // Use writable store for dictionary settings
  const dictionarySettings = writable<DictionarySettings>({ words: [] });

  // New word to be added
  let newWord = '';

  onMount(async () => {
    const storedSettings = await window.api.getStoreValue('dictionary') as DictionarySettings | undefined;
    if (storedSettings) {
      dictionarySettings.set({ ...storedSettings }); // Use set for writable store
    }
    // Mark loading as complete *after* initial load
    isLoading = false;
  });

  // Debounced save function
  let saveTimeout: NodeJS.Timeout | null = null;
  const saveSettings = (currentSettings: DictionarySettings) => {
      if (isLoading) return; // Prevent saving during initial load
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(async () => {
          try {
              await window.api.setStoreValue('dictionary', currentSettings);
              window.api.log('info', 'Dictionary settings auto-saved.');
          } catch (error) {
              window.api.log('error', 'Failed to auto-save dictionary settings:', error);
          }
      }, 500); // Debounce 500ms
  };

  // Reactive statement to save when words array changes
  $: if ($dictionarySettings?.words) {
      // Check isLoading to prevent saving on initial mount
      if (!isLoading) {
          saveSettings($dictionarySettings);
      }
  }

  // Add a new word to dictionary
  const addWord = (): void => {
    if (newWord.trim() === '') return;

    // Check if word already exists using get() for current value
    if (!get(dictionarySettings).words.includes(newWord.trim())) {
      // Update the store using update()
      dictionarySettings.update(settings => ({
          ...settings,
          words: [...settings.words, newWord.trim()]
      }));
      newWord = '';
    }
  };

  // Remove a word from dictionary using update()
  const removeWord = (wordToRemove: string): void => {
    dictionarySettings.update(settings => ({
        ...settings,
        words: settings.words.filter(w => w !== wordToRemove)
    }));
  };

  // UI feedback
  // let saveSuccess = false; // Removed
  let isLoading = true; // Added loading flag
</script>

<div class="p-4">
  <h2 class="text-2xl font-bold mb-6">Custom Dictionary</h2>

  <div class="bg-base-100 max-w-xl">
      <p class="text-sm opacity-70 mb-4">
        Add custom words, technical terms, or names to improve transcription accuracy. This only works if you enable enhancements.
      </p>

      <div class="form-control">
        <div class="input-group">
          <input
            type="text"
            class="input input-bordered flex-1"
            placeholder="Enter a custom word..."
            bind:value={newWord}
            on:keypress={(e): void => { if (e.key === 'Enter') addWord(); }}
          />
          <button class="btn btn-primary" on:click={addWord}>
            Add Word
          </button>
        </div>
      </div>

      <div class="mt-6">
        <h4 class="font-semibold mb-2">Current Dictionary</h4>

        {#if $dictionarySettings.words.length === 0}
          <div class="bg-base-200 p-4 text-center rounded-lg">
            <p class="opacity-60">Your custom dictionary is empty</p>
            <p class="text-sm mt-1 opacity-50">Add words above to improve transcription accuracy</p>
          </div>
        {:else}
          <div class="flex flex-wrap gap-2">
            {#each $dictionarySettings.words as word}
              <div class="badge badge-lg flex gap-1 p-1 pl-3">
                <span>{word}</span>
                <button
                  class="btn btn-xs btn-ghost btn-circle"
                  aria-label={`Remove word ${word}`}
                  on:click={(): void => { removeWord(word); }}
                >
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>
            {/each}
          </div>
        {/if}

        {#if $dictionarySettings.words.length > 0}
          <button
            class="btn btn-xs btn-outline mt-4"
            on:click={() => dictionarySettings.update(s => ({ ...s, words: [] }))}
          >
            Clear All
          </button>
        {/if}
      </div>

      <div class="bg-base-200 rounded-md p-3 mt-6">
        <h4 class="font-semibold mb-1">How it works:</h4>
        <p class="text-sm opacity-80">
          Words added to your custom dictionary will be given higher priority during transcription.
          This is especially useful for technical terms, uncommon names, or domain-specific jargon
          that might otherwise be misinterpreted.
        </p>
      </div>

      <!-- Removed Save Success Alert -->

      <!-- Removed Save Button -->
    </div>
  </div>

================
File: components/settings/Enhancements.svelte
================
<script lang="ts">
  import { onMount } from 'svelte';
  import { v4 as uuidv4 } from 'uuid';
  import { writable, get } from 'svelte/store';

  interface EnhancementSettings {
    enabled: boolean;
    provider: 'openai' | 'gemini' | 'custom';
    openaiApiKey: string;
    openaiModel: 'gpt-4.1' | 'gpt-4.1-mini';
    openaiBaseUrl?: string;
    geminiApiKey: string;
    geminiModel: 'gemini-2.0-flash' | 'gemini-2.5-flash' | 'gemini-2.0-flash-lite';
    customApiKey: string;
    customModelName: string;
    customBaseUrl?: string;
    activePromptId: string;
    useTranscript: boolean;
    useContextScreen: boolean;
    useContextInputField: boolean;
    useContextClipboard: boolean;
    useDictionaryWordList: boolean;
  }

  interface EnhancementPrompt {
    id: string;
    name: string;
    template: string;
  }

  const settings = writable<EnhancementSettings>({
    enabled: false,
    provider: 'openai',
    openaiApiKey: '',
    openaiModel: 'gpt-4.1-mini',
    openaiBaseUrl: '',
    geminiApiKey: '',
    geminiModel: 'gemini-2.0-flash',
    customApiKey: '',
    customModelName: '',
    customBaseUrl: '',
    activePromptId: 'default',
    useTranscript: true,
    useContextScreen: false,
    useContextInputField: false,
    useContextClipboard: false,
    useDictionaryWordList: false
  });

  let isLoading = true;
  const prompts = writable<EnhancementPrompt[]>([]);
  let newPromptName = '';
  let newPromptTemplate = '';
  let showAddPrompt = false;
  let showPromptModal = false;
  let modalMode: 'view' | 'edit' | 'add' = 'add';
  let currentPrompt: EnhancementPrompt | { id: 'default', name: string, template: string } | null = null;
  let editPromptName = '';
  let editPromptTemplate = '';

  onMount(async () => {
    try {
      const storedSettingsPromise = window.api.getStoreValue('enhancements') as Promise<EnhancementSettings | undefined>;
      const storedPromptsPromise = window.api.getStoreValue('enhancementPrompts') as Promise<EnhancementPrompt[] | undefined>;

      const [storedSettings, storedPrompts] = await Promise.all([storedSettingsPromise, storedPromptsPromise]);

      if (storedSettings) {
        settings.set({ ...storedSettings });
      }
      if (storedPrompts) {
        prompts.set([...storedPrompts]);
      }
    } catch (error) {
      window.api.log('error', 'Failed to load enhancement settings:', error);
    } finally {
      isLoading = false;
    }
  });

  $: if (!isLoading && $settings) {
      saveSettings($settings);
  }

  let saveTimeout: NodeJS.Timeout | null = null;
  const saveSettings = (currentSettings: EnhancementSettings) => {
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(async () => {
          try {
              await window.api.setStoreValue('enhancements', currentSettings);
              window.api.log('info', 'Enhancement settings auto-saved.');
          } catch (error) {
              window.api.log('error', 'Failed to auto-save enhancement settings:', error);
          }
      }, 500);
  };

  const addPrompt = async () => {
    if (!newPromptName.trim() || !newPromptTemplate.trim()) {
      alert('Please provide both a name and a template for the new prompt.');
      return;
    }
    const newPrompt: EnhancementPrompt = {
      id: uuidv4(),
      name: newPromptName.trim(),
      template: newPromptTemplate.trim()
    };
    const currentPrompts = get(prompts);
    const updatedPrompts = [...currentPrompts, newPrompt];
    try {
      await window.api.setStoreValue('enhancementPrompts', updatedPrompts);
      prompts.set(updatedPrompts);
      newPromptName = '';
      newPromptTemplate = '';
      showAddPrompt = false;
      window.api.log('info', `Added new enhancement prompt: ${newPrompt.name}`);
    } catch (error) {
      window.api.log('error', 'Failed to save new prompt:', error);
      alert('Failed to save the new prompt.');
    }
  };

  const deletePrompt = async (idToDelete: string) => {
    if (idToDelete === 'default') return;
    if (!confirm('Are you sure you want to delete this prompt?')) return;

    const currentPrompts = get(prompts);
    const updatedPrompts = currentPrompts.filter(p => p.id !== idToDelete);
    try {
      await window.api.setStoreValue('enhancementPrompts', updatedPrompts);
      prompts.set(updatedPrompts);

      if (get(settings).activePromptId === idToDelete) {
        settings.update(s => ({ ...s, activePromptId: 'default' }));
        await saveSettings(get(settings));
      }
      window.api.log('info', `Deleted enhancement prompt ID: ${idToDelete}`);
    } catch (error) {
      window.api.log('error', 'Failed to delete prompt:', error);
      alert('Failed to delete the prompt.');
    }
  };

  const closeModal = () => {
    showPromptModal = false;
    currentPrompt = null;
    editPromptName = '';
    editPromptTemplate = '';
  };

  const viewPrompt = async (promptId: string) => {
    if (promptId === 'default') {
      try {
        const defaultTemplate = await window.api.getDefaultPromptContent();
        currentPrompt = {
          id: 'default',
          name: 'Default Prompt',
          template: defaultTemplate
        };
      } catch (err) {
        window.api.log('error', 'Failed to fetch default prompt content:', err);
        alert('Could not load default prompt content.');
        return;
      }
    } else {
      currentPrompt = get(prompts).find(p => p.id === promptId) || null;
    }

    if (currentPrompt) {
      modalMode = 'view';
      editPromptName = currentPrompt.name;
      editPromptTemplate = currentPrompt.template;
      showPromptModal = true;
    } else {
      window.api.log('error', `Prompt not found for viewing: ${promptId}`);
    }
  };

  const editPrompt = (promptToEdit: EnhancementPrompt) => {
    currentPrompt = promptToEdit;
    modalMode = 'edit';
    editPromptName = promptToEdit.name;
    editPromptTemplate = promptToEdit.template;
    showPromptModal = true;
  };

  const saveEditedPrompt = async () => {
    if (!currentPrompt || currentPrompt.id === 'default') return;
    if (!editPromptName.trim() || !editPromptTemplate.trim()) {
      alert('Prompt name and template cannot be empty.');
      return;
    }

    const updatedPrompt: EnhancementPrompt = {
      ...currentPrompt,
      name: editPromptName.trim(),
      template: editPromptTemplate.trim()
    };

    const currentPrompts = get(prompts);
    const updatedPrompts = currentPrompts.map(p => p.id === updatedPrompt.id ? updatedPrompt : p);

    try {
      await window.api.setStoreValue('enhancementPrompts', updatedPrompts);
      prompts.set(updatedPrompts);
      window.api.log('info', `Updated prompt: ${updatedPrompt.name}`);
      closeModal();
    } catch (error) {
      window.api.log('error', 'Failed to save updated prompt:', error);
      alert('Failed to save the updated prompt.');
    }
  };

</script>

<div class="p-4 space-y-6">
  <h2 class="text-xl font-semibold">Enhancement Settings</h2>

  {#if isLoading}
    <p>Loading settings...</p>
  {:else}
    <div class="bg-base-100 max-w-2xl space-y-6">

        <div class="form-control">
          <label class="label cursor-pointer">
            <span class="label-text font-semibold">Enable Enhancements</span>
            <input
              type="checkbox"
              class="toggle toggle-primary"
              bind:checked={$settings.enabled}
            />
          </label>
          <p class="text-sm opacity-70 ml-1">
            When enabled, transcriptions can be processed by an LLM to improve formatting, fix grammar, etc.
          </p>
            <label class="label"><span class="label-text-alt">Must be OpenAI API compatible.</span></label>
          </div>

        {#if $settings.enabled}
          <div class="divider pt-4">Enhancement Provider</div>

          <div class="flex flex-wrap gap-4 items-center">
             <div class="form-control">
               <label class="label cursor-pointer gap-2">
                 <input type="radio" name="enhancement-provider" class="radio radio-sm" value="openai" bind:group={$settings.provider} />
                 <span class="label-text">OpenAI</span>
               </label>
             </div>
             <div class="form-control">
               <label class="label cursor-pointer gap-2">
                 <input type="radio" name="enhancement-provider" class="radio radio-sm" value="gemini" bind:group={$settings.provider} />
                 <span class="label-text">Gemini</span>
               </label>
             </div>
             <div class="form-control">
               <label class="label cursor-pointer gap-2">
                 <input type="radio" name="enhancement-provider" class="radio radio-sm" value="custom" bind:group={$settings.provider} />
                 <span class="label-text">Custom</span>
               </label>
             </div>
          </div>

          {#if $settings.provider === 'openai'}
            <div class="mt-4 p-4 border border-base-300 rounded-md space-y-4">
               <h3 class="font-medium">OpenAI Configuration</h3>
               <div class="form-control">
                 <label class="label" for="openai-enh-api-key">
                   <span class="label-text">OpenAI API Key*</span>
                 </label>
                 <input id="openai-enh-api-key" type="password" placeholder="sk-..." class="input input-bordered input-sm w-full" bind:value={$settings.openaiApiKey} />
               </div>
               <div class="form-control">
                 <label class="label" for="openai-enh-model-select">
                   <span class="label-text">OpenAI Model*</span>
                 </label>
                 <select id="openai-enh-model-select" class="select select-bordered select-sm w-full max-w-xs" bind:value={$settings.openaiModel}>
                   <option value="gpt-4.1-mini">GPT-4.1 Mini</option>
                   <option value="gpt-4.1">GPT-4.1</option>
                 </select>
               </div>

            </div>
          {:else if $settings.provider === 'gemini'}
             <div class="mt-4 p-4 border border-base-300 rounded-md space-y-4">
                <h3 class="font-medium">Gemini Configuration</h3>
                <div class="form-control">
                  <label class="label" for="gemini-api-key">
                    <span class="label-text">Gemini API Key*</span>
                  </label>
                  <input id="gemini-api-key" type="password" placeholder="AIza..." class="input input-bordered input-sm w-full" bind:value={$settings.geminiApiKey} />
                </div>
                <div class="form-control">
                  <label class="label" for="gemini-model-select">
                    <span class="label-text">Gemini Model*</span>
                  </label>
                  <select id="gemini-model-select" class="select select-bordered select-sm w-full max-w-xs" bind:value={$settings.geminiModel}>
                    <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                    <option value="gemini-2.0-flash-lite">Gemini 2.0 Flash Lite</option>
                    <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                  </select>
                </div>
             </div>
          {:else if $settings.provider === 'custom'}
             <div class="mt-4 p-4 border border-base-300 rounded-md space-y-4">
                <h3 class="font-medium">Custom Provider Configuration</h3>

                <div class="form-control">
                  <label class="label" for="custom-base-url">
                    <span class="label-text">Base URL</span>
                  </label>
                  <input id="custom-base-url" type="text" placeholder="eg. https://api.mistral.ai/v1/" class="input input-bordered input-sm w-full" bind:value={$settings.customBaseUrl} />
                   <label class="label"><span class="label-text-alt text-xs">Must be OpenAI API compatible.</span></label>
                </div>

                <div class="form-control">
                  <label class="label" for="custom-model-name">
                    <span class="label-text">Model Name</span>
                  </label>
                  <input id="custom-model-name" type="text" placeholder="e.g. mistral-small-latest" class="input input-bordered input-sm w-full" bind:value={$settings.customModelName} />
                </div>


                 <div class="form-control">
                   <label class="label" for="custom-api-key">
                     <span class="label-text">API Key</span>
                   </label>
                   <input id="custom-api-key" type="password" placeholder="Enter API Key" class="input input-bordered input-sm w-full" bind:value={$settings.customApiKey} />
                 </div>

             </div>
          {/if}

          <div class="divider py-4">Context Variables</div>
          <p class="text-sm opacity-70 -mt-4 mb-4">
            Enable context sources to include them in your prompts using placeholders like <code class="kbd kbd-xs">{'{{context_screen}}'}</code>. (Note: Context capture is not yet implemented).
          </p>
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-2">
              <div class="form-control">
                  <label class="label cursor-pointer justify-start gap-3">
                      <input type="checkbox" class="toggle toggle-sm" bind:checked={$settings.useContextScreen} />
                      <span class="label-text">Screen Content</span>
                      <span class="tooltip tooltip-right" data-tip="Include text content from the active screen (if available). Use {'{{context_screen}}'} in prompt.">
                          <i class="ri-information-line opacity-50"></i>
                      </span>
                  </label>
              </div>
              <div class="form-control">
                  <label class="label cursor-pointer justify-start gap-3">
                      <input type="checkbox" class="toggle toggle-sm" bind:checked={$settings.useContextInputField} />
                      <span class="label-text">Input Field</span>
                       <span class="tooltip tooltip-right" data-tip="Include text content from the active input field (if available). Use {'{{context_input_field}}'} in prompt.">
                          <i class="ri-information-line opacity-50"></i>
                      </span>
                  </label>
              </div>
              <div class="form-control">
                  <label class="label cursor-pointer justify-start gap-3">
                      <input type="checkbox" class="toggle toggle-sm" bind:checked={$settings.useContextClipboard} />
                      <span class="label-text">Clipboard</span>
                       <span class="tooltip tooltip-right" data-tip="Include text content from the clipboard. Use {'{{context_clipboard}}'} in prompt.">
                          <i class="ri-information-line opacity-50"></i>
                      </span>
                  </label>
              </div>
          </div>

          <div class="divider pt-4">Active Enhancement Prompt</div>
          <div class="space-y-2">
             <div class="form-control">
                <label class="label cursor-pointer justify-start gap-2 p-2 rounded hover:bg-base-300 group">
                  <input type="radio" name="active-prompt" class="radio radio-sm" value="default" bind:group={$settings.activePromptId} />
                  <span class="label-text font-medium">Default Prompt</span>
                  <span class="text-xs opacity-60 ml-auto mr-2">(Basic formatting)</span>
                   <button
                     class="btn btn-xs btn-ghost opacity-0 group-hover:opacity-100 transition-opacity"
                     title="View Default Prompt"
                     on:click|stopPropagation|preventDefault={() => viewPrompt('default')}
                   >
                     <i class="ri-eye-line"></i>
                   </button>
                </label>
             </div>
             {#each $prompts as prompt (prompt.id)}
                <div class="form-control">
                  <label class="label cursor-pointer justify-start gap-2 p-2 rounded hover:bg-base-300 group">
                    <input type="radio" name="active-prompt" class="radio radio-sm" value={prompt.id} bind:group={$settings.activePromptId}  />
                    <span class="label-text flex-1 truncate" title={prompt.name}>{prompt.name}</span>
                    <button
                      class="btn btn-xs btn-ghost opacity-0 group-hover:opacity-100 transition-opacity mr-1"
                      title="Edit Prompt"
                      on:click|stopPropagation|preventDefault={() => editPrompt(prompt)}
                    >
                       <i class="ri-pencil-line"></i>
                    </button>

                    <button
                      class="btn btn-xs btn-ghost text-error opacity-0 group-hover:opacity-100 transition-opacity"
                      title="Delete Prompt"
                      on:click|stopPropagation|preventDefault={() => deletePrompt(prompt.id)}
                    >
                      <i class="ri-delete-bin-line"></i>
                    </button>
                  </label>
                </div>
             {/each}
          </div>

          <div class="mt-4">
             {#if showAddPrompt}
                <div class="p-4 border border-base-300 rounded-md space-y-3">
                   <h4 class="font-medium">Add New Prompt</h4>
                   <div class="form-control">
                      <label class="label py-1" for="new-prompt-name"><span class="label-text">Prompt Name:</span></label>
                      <input id="new-prompt-name" type="text" placeholder="e.g., Formal Report Style" class="input input-bordered input-sm w-full" bind:value={newPromptName} />
                   </div>
                    <div class="form-control">
                      <label class="label py-1" for="new-prompt-template"><span class="label-text">Prompt Template:</span></label>
                      <textarea id="new-prompt-template" class="textarea textarea-bordered w-full" rows="4" placeholder="Enter your prompt. Use {'{{transcription}}'} where the text should be inserted." bind:value={newPromptTemplate}></textarea>
                      <span class="pt-2 block-inline text-sm">Use <a target="_blank" class="underline" href="https://mustache.github.io/mustache.5.html">mustache templating</a>. Variables: <code class="kbd kbd-xs h-auto">{'{{transcription}}, {{dictionary_words}}, {{context_screen}}, {{context_clipboard}}, {{context_input_field}}'}</code></span>
                   </div>
                   <div class="flex justify-end gap-2 pt-2">
                      <button class="btn btn-sm btn-ghost" on:click={() => { showAddPrompt = false; newPromptName=''; newPromptTemplate=''; }}>Cancel</button>
                      <button class="btn btn-sm btn-primary" on:click={addPrompt}>Add Prompt</button>
                   </div>
                </div>
             {:else}
                <button class="btn btn-sm btn-outline" on:click={() => { showAddPrompt = true; }}>
                   <i class="ri-add-line"></i> Add Custom Prompt
                </button>
             {/if}
          </div>

        {/if}

      </div>
  {/if}
</div>

{#if showPromptModal && currentPrompt}
<dialog id="prompt_modal" class="modal modal-open">
  <div class="modal-box w-11/12 max-w-2xl">
    <h3 class="font-bold text-lg mb-4">
      {#if modalMode === 'view'}
        View Prompt: {currentPrompt.name}
      {:else if modalMode === 'edit'}
        Edit Prompt: {currentPrompt.name}
      {/if}
    </h3>

    {#if modalMode === 'view'}
      <div class="space-y-4">
        <div>
          <label class="label"><span class="label-text font-semibold">Name:</span></label>
          <p class="p-2 bg-base-200 rounded">{currentPrompt.name}</p>
        </div>
        <div>
          <label class="label"><span class="label-text font-semibold">Template:</span></label>
          <pre class="p-2 bg-base-200 rounded text-sm whitespace-pre-wrap break-words max-h-60 overflow-y-auto">{currentPrompt.template}</pre>
        </div>
      </div>
    {:else if modalMode === 'edit'}
      <div class="space-y-4">
         <div class="form-control">
            <label class="label py-1" for="edit-prompt-name"><span class="label-text">Prompt Name:</span></label>
            <input id="edit-prompt-name" type="text" class="input input-bordered w-full" bind:value={editPromptName} />
         </div>
          <div class="form-control">
            <label class="label py-1" for="edit-prompt-template"><span class="label-text">Prompt Template:</span></label>
            <textarea id="edit-prompt-template" class="textarea textarea-bordered w-full" rows="6" placeholder="Use {'{{transcription}}'} where the text should be inserted." bind:value={editPromptTemplate}></textarea>
         </div>
      </div>
    {/if}

    <div class="modal-action mt-6">
      <button class="btn btn-ghost" on:click={closeModal}>Close</button>
      {#if modalMode === 'edit'}
        <button class="btn btn-primary" on:click={saveEditedPrompt}>Save Changes</button>
      {/if}
    </div>
  </div>
  <form method="dialog" class="modal-backdrop">
    <button on:click={closeModal}>close</button>
  </form>
</dialog>
{/if}

================
File: components/settings/History.svelte
================
<script lang="ts">
  import { onMount, onDestroy } from "svelte";
  import { writable } from "svelte/store";

  const historyData = writable<PaginatedHistory | null>(null);
  const selectedEntry = writable<HistoryRecord | null>(null);
  const isLoading = writable(true);
  const error = writable<string | null>(null);

  const DEFAULT_PAGE_SIZE = 6;

  async function fetchHistory(
    page = 1,
    pageSize = DEFAULT_PAGE_SIZE,
  ): Promise<void> {
    isLoading.set(true);
    error.set(null);
    selectedEntry.set(null);
    try {
      const data = await window.api.getHistory(page, pageSize);
      if (data) {
        console.log(data);
        historyData.set(data);
      } else {
        historyData.set({
          entries: [],
          totalEntries: 0,
          totalPages: 0,
          currentPage: 1,
        });
        error.set("Failed to load history data.");
      }
      window.api.log("info", `History page ${page} loaded.`);
    } catch (err) {
      window.api.log("error", "Error fetching history:", err);
      error.set(`Error loading history: ${err.message}`);
      historyData.set({
        entries: [],
        totalEntries: 0,
        totalPages: 0,
        currentPage: 1,
      }); // Set empty state on error
    } finally {
      isLoading.set(false);
    }
  }

  async function deleteEntry(id: string): Promise<void> {
    if (!confirm("Are you sure you want to delete this history entry?")) return;
    try {
      const success = await window.api.deleteHistoryEntry(id);
      if (success) {
        window.api.log("info", `History entry ${id} deleted.`);
        // Refresh current page
        fetchHistory($historyData?.currentPage || 1);
      } else {
        error.set("Failed to delete entry.");
      }
    } catch (err) {
      window.api.log("error", `Error deleting history entry ${id}:`, err);
      error.set(`Error deleting entry: ${err.message}`);
    }
  }

  async function clearAll(): Promise<void> {
    if (
      !confirm(
        "Are you sure you want to delete ALL history entries? This cannot be undone.",
      )
    )
      return;
    try {
      const success = await window.api.clearAllHistory();
      if (success) {
        window.api.log("info", "All history cleared.");
        fetchHistory(1); // Refresh to show empty list
      } else {
        error.set("Failed to clear history.");
      }
    } catch (err) {
      window.api.log("error", "Error clearing history:", err);
      error.set(`Error clearing history: ${err.message}`);
    }
  }

  function selectEntry(entry: HistoryRecord): void {
    selectedEntry.set(entry);
  }

  function formatTimestamp(timestamp: number): string {
    return new Date(timestamp).toLocaleString();
  }

  function truncateText(text: string, maxLength = 100): string {
    if (!text) return "";
    return text.length > maxLength
      ? text.substring(0, maxLength) + "..."
      : text;
  }

  onMount(() => {
    fetchHistory();

    const cleanupResultListener = window.api.onTranscriptionResult(() => {
      window.api.log(
        "info",
        "History page received transcription result, refreshing list.",
      );
      fetchHistory(1); // Fetch the first page
    });

    onDestroy(() => {
      cleanupResultListener();
    });
  });
</script>

<div class="p-4 space-y-6">
  <div class="flex justify-between items-center">
    <h2 class="text-xl font-semibold">Latest Transcriptions</h2>
    {#if $historyData && $historyData.totalEntries > 0}
      <button
        class="btn btn-sm btn-outline btn-error"
        on:click={clearAll}
        disabled={$isLoading}
      >
        Clear All History
      </button>
    {/if}
  </div>

  {#if $isLoading}
    <div class="text-center p-10">
      <span class="loading loading-lg loading-spinner"></span>
      <p>Loading History...</p>
    </div>
  {:else if $error}
    <div class="alert alert-error">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="stroke-current shrink-0 h-6 w-6"
        fill="none"
        viewBox="0 0 24 24"
        ><path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M10 14l2-2m0 0l2-2m-2 2l-2 2m2-2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"
        /></svg
      >
      <span>{$error}</span>
    </div>
  {:else if $historyData && $historyData.entries.length > 0}
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
      <!-- Entry List -->
      <div class="md:col-span-1 space-y-2 overflow-y-auto pr-2">
        {#each $historyData.entries as entry (entry.id)}
          <div
            class="p-3 rounded-md border cursor-pointer transition-colors"
            class:border-primary={$selectedEntry?.id === entry.id}
            class:bg-base-200={$selectedEntry?.id === entry.id}
            class:border-base-300={$selectedEntry?.id !== entry.id}
            class:hover:bg-base-200={$selectedEntry?.id !== entry.id}
            on:click={() => selectEntry(entry)}
            role="button"
            tabindex="0"
            on:keypress={(e) => {
              if (e.key === "Enter") selectEntry(entry);
            }}
          >
            <p class="text-sm font-medium truncate" title={entry.originalText}>
              {truncateText(entry.originalText)}
            </p>
            <p class="text-xs opacity-60 mt-1">
              {formatTimestamp(entry.timestamp)}
            </p>
          </div>
        {/each}

        <!-- Pagination -->
        {#if $historyData.totalPages > 1}
          <div class="join mt-4 flex justify-center">
            <button
              class="join-item btn btn-sm"
              disabled={$historyData.currentPage <= 1}
              on:click={() => fetchHistory($historyData.currentPage - 1)}
              >Â«</button
            >
            <button class="join-item btn btn-sm"
              >Page {$historyData.currentPage} / {$historyData.totalPages}</button
            >
            <button
              class="join-item btn btn-sm"
              disabled={$historyData.currentPage >= $historyData.totalPages}
              on:click={() => fetchHistory($historyData.currentPage + 1)}
              >Â»</button
            >
          </div>
        {/if}
      </div>

      <!-- Entry Details -->
      <div class="md:col-span-2">
        {#if $selectedEntry}
          <div class="card bg-base-100 border border-base-300">
            <div class="card-body">
              <div class="flex justify-between items-start mb-4">
                <h3 class="card-title text-lg">Details</h3>
                <button
                  class="btn btn-xs btn-ghost text-error"
                  title="Delete Entry"
                  on:click|stopPropagation={() =>
                    deleteEntry($selectedEntry!.id)}
                >
                  <i class="ri-delete-bin-line"></i> Delete
                </button>
              </div>

              <p class="text-xs opacity-60 mb-4">
                Recorded: {formatTimestamp($selectedEntry.timestamp)}
              </p>

              <div class="space-y-4">
                <div>
                  <h4 class="font-semibold mb-1">Original Transcription</h4>
                  <div
                    class="bg-base-200 p-3 rounded text-sm whitespace-pre-wrap break-words max-h-40 overflow-y-auto"
                  >
                    {$selectedEntry.originalText || "(empty)"}
                  </div>
                </div>

                {#if $selectedEntry.promptNameUsed}
                  <h4 class="font-semibold mb-1">Prompt: {$selectedEntry.promptNameUsed}</h4>
                {/if}
                {#if $selectedEntry.renderedPrompt}
                    <div class="collapse collapse-arrow bg-base-200/50">
                        <input type="checkbox" />
                        <div class="collapse-title text-xs font-medium">
                            View Rendered Prompt
                        </div>
                        <div class="collapse-content">
                            <pre class="text-xs whitespace-pre-wrap break-words overflow-y-auto">{$selectedEntry.renderedPrompt}</pre>
                        </div>
                    </div>
                {/if}

                {#if $selectedEntry.enhancedText}
                  <div>
                    <h4 class="font-semibold mb-1">Enhanced Text</h4>
                    <div
                      class="bg-success/10 p-3 rounded text-sm whitespace-pre-wrap break-words max-h-40 overflow-y-auto"
                    >
                      {$selectedEntry.enhancedText}
                    </div>

                  </div>
                {/if}
              </div>
            </div>
          </div>
        {:else}
          <div
            class="flex items-center justify-center h-full bg-base-200 rounded-md p-10"
          >
            <p class="opacity-60">
              Select an entry from the list to view details.
            </p>
          </div>
        {/if}
      </div>
    </div>
  {:else}
    <div class="text-center p-10 bg-base-200 rounded-md">
      <p class="opacity-60">No transcription history found.</p>
      <p class="text-sm mt-1 opacity-50">
        Recordings will appear here after they are transcribed.
      </p>
    </div>
  {/if}
</div>

================
File: components/settings/Logs.svelte
================
<script lang="ts">
  import { onMount, onDestroy } from "svelte";
  import { writable, get } from "svelte/store";

  const logLines = writable<string[]>([]);
  const isLoading = writable(true);
  const maxLines = writable(500);
  const copied = writable(false);
  let copyTimeout: ReturnType<typeof setTimeout>;

  onMount(async () => {
    isLoading.set(true);
    try {
      const initialLogs = await window.api.getLogLines(get(maxLines));
      logLines.set(initialLogs);
      window.api.log('info', `Logs component mounted, loaded ${initialLogs.length} lines.`);
    } catch (error) {
      window.api.log('error', 'Failed to load initial logs:', error);
      logLines.set(['Error loading logs.']);
    } finally {
      isLoading.set(false);
    }
  });

  onDestroy(() => {
    clearTimeout(copyTimeout);
  });

  async function refreshLogs() {
     isLoading.set(true);
     try {
       const refreshedLogs = await window.api.getLogLines(get(maxLines));
       logLines.set(refreshedLogs);
       window.api.log('info', `Refreshed logs, loaded ${refreshedLogs.length} lines.`);
     } catch (error) {
       window.api.log('error', 'Failed to refresh logs:', error);
       logLines.set(['Error refreshing logs.']);
     } finally {
       isLoading.set(false);
     }
  }

  async function copyLogs() {
    try {
      const logsText = get(logLines).join('\n');
      await navigator.clipboard.writeText(logsText);
      copied.set(true);
      window.api.log('info', 'Copied logs to clipboard.');
      clearTimeout(copyTimeout);
      copyTimeout = setTimeout(() => copied.set(false), 2000);
    } catch (error) {
      window.api.log('error', 'Failed to copy logs to clipboard:', error);
    }
  }

</script>

<div class="p-4 space-y-4">
  <h2 class="text-xl font-semibold">Application Logs</h2>

  <div class="flex items-center space-x-4">
     <button class="btn btn-sm btn-secondary" on:click={refreshLogs} disabled={$isLoading}>
        Refresh
     </button>
     <button class="btn btn-sm" on:click={copyLogs} disabled={$isLoading || $logLines.length === 0}>
        {#if $copied} Copied! {:else} Copy {/if}
     </button>
  </div>

  <div class="bg-base-200 p-4 rounded-md font-mono text-xs overflow-auto h-96 select-text">
    {#if $isLoading}
      <p>Loading logs...</p>
    {:else}
      <pre>{$logLines.join('\n')}</pre>
    {/if}
  </div>
</div>

================
File: components/settings/Permissions.svelte
================
<script lang="ts">
  import { onMount } from 'svelte';

  // Include 'not-determined' and 'unknown' as possible statuses from the API
  type PermissionStatus = 'checking' | 'granted' | 'not-granted' | 'unavailable' | 'denied' | 'restricted' | 'unknown' | 'not-determined';

  // Reactive state for permissions
  let accessibilityStatus: PermissionStatus = 'checking';
  let microphoneStatus: PermissionStatus = 'checking';
  let screenRecordingStatus: PermissionStatus = 'checking';
  let showManualInstructions = false; // State to show instructions after prompt

  // --- Accessibility ---
  async function checkAccessibilityStatus(): Promise<void> {
    window.api.log('debug', 'Checking Accessibility status...');
    accessibilityStatus = 'checking';
    showManualInstructions = false;
    try {
        const status = await window.api.getAccessibilityStatus();
        accessibilityStatus = status;
        window.api.log('info', 'Accessibility status:', status);
    } catch (error) {
        window.api.log('error', 'Error checking accessibility status:', error);
        accessibilityStatus = 'unavailable';
    }
  }

  async function requestAccessibility(): Promise<void> {
    window.api.log('info', 'Requesting Accessibility access (will prompt user)...');
    showManualInstructions = false;
    try {
        await window.api.requestAccessibilityAccess();
        window.api.log('info', 'Accessibility prompt shown. User needs to grant access in System Settings.');
        showManualInstructions = true;
        setTimeout(checkAccessibilityStatus, 5000);
    } catch (error) {
        window.api.log('error', 'Error requesting accessibility access:', error);
    }
  }

  // --- Media Permissions ---
  async function checkMediaStatus(mediaType: 'microphone' | 'screen'): Promise<void> {
      window.api.log('debug', `Checking ${mediaType} status...`);
      if (mediaType === 'microphone') microphoneStatus = 'checking';
      if (mediaType === 'screen') screenRecordingStatus = 'checking';

      try {
          // Ensure the status received from API matches our defined type
          const status = await window.api.getMediaPermissionStatus(mediaType) as PermissionStatus;
          if (mediaType === 'microphone') microphoneStatus = status;
          if (mediaType === 'screen') screenRecordingStatus = status;
          window.api.log('info', `${mediaType} status:`, status);
      } catch (error) {
          window.api.log('error', `Error checking ${mediaType} status:`, error);
          if (mediaType === 'microphone') microphoneStatus = 'unavailable';
          if (mediaType === 'screen') screenRecordingStatus = 'unavailable';
      }
  }

  async function requestMicrophone(): Promise<void> {
      window.api.log('info', 'Requesting Microphone access...');
      try {
          const granted = await window.api.requestMediaPermission('microphone');
          window.api.log('info', `Microphone access request result: ${granted}`);
          setTimeout(() => checkMediaStatus('microphone'), 1000);
          if (!granted) {
              window.api.log('warn', 'Microphone access denied or failed. Guide user to System Settings.');
          }
      } catch (error) {
          window.api.log('error', 'Error requesting microphone access:', error);
      }
  }

  function openScreenRecordingSettings(): void {
      window.api.log('info', 'Opening Screen Recording privacy settings via IPC...');
      // Use IPC to ask main process to open the URL
      window.api.openSettingsURL('x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture');
      setTimeout(() => checkMediaStatus('screen'), 5000);
  }

  // --- Lifecycle ---
  onMount(() => {
    if (navigator.platform.toUpperCase().indexOf('MAC') >= 0) {
        checkAccessibilityStatus();
        checkMediaStatus('microphone');
        checkMediaStatus('screen');
    } else {
        accessibilityStatus = 'unavailable';
        microphoneStatus = 'unavailable';
        screenRecordingStatus = 'unavailable';
    }
  });

  // Helper to get badge class
  function getBadgeClass(status: PermissionStatus): string {
      switch (status) {
          case 'granted': return 'badge-success';
          case 'denied':
          case 'restricted':
          case 'not-granted': return 'badge-error';
          case 'checking': return 'badge-ghost';
          default: return 'badge-ghost';
      }
  }

  // Helper to get status text
   function getStatusText(status: PermissionStatus): string {
      switch (status) {
          case 'granted': return 'Granted';
          case 'denied': return 'Denied';
          case 'restricted': return 'Restricted';
          case 'not-granted': return 'Not Granted';
          case 'checking': return 'Checking...';
          case 'not-determined': return 'Not Set';
          case 'unknown': return 'Unknown';
          default: return 'N/A';
      }
  }

</script>

<div class="p-4">
  <h2 class="text-2xl font-bold mb-6">Permissions</h2>

  <div class="bg-base-100 max-w-xl">
      <p class="text-sm opacity-70 mb-4">
        Vox Transcriber needs the following permissions to function properly.
      </p>

      <div class="space-y-6">
        <div class="flex items-start gap-4">
          <div class="bg-base-200 p-3 rounded-full mt-1">
            <span class="text-xl font-bold">âŒ¨ï¸</span>
          </div>
          <div class="flex-1">
            <h4 class="font-semibold">Accessibility Features</h4>
            <p class="text-sm opacity-70">Required for global keyboard shortcuts.</p>
            <div class="flex items-center gap-2 mt-1">
              <span class="badge {getBadgeClass(accessibilityStatus)} gap-1">
                 {#if accessibilityStatus !== 'checking' && accessibilityStatus !== 'unavailable'}
                    <span class="bg-white rounded-full w-2 h-2"></span>
                 {/if}
                 {getStatusText(accessibilityStatus)}
              </span>
            </div>
             {#if accessibilityStatus === 'not-granted'}
                <div class="mt-2">
                    <button class="btn btn-primary btn-sm" on:click={requestAccessibility}>
                      Request Access
                    </button>
                    {#if showManualInstructions}
                        <p class="text-xs text-warning mt-2">
                            System Settings should open. Please find 'Vox Transcriber' (or 'key-monitor') in the Accessibility list, click '+', add it if missing, and ensure the toggle is ON. You may need to restart the app.
                        </p>
                    {/if}
                </div>
             {/if}
          </div>
           {#if accessibilityStatus === 'granted'}
             <span class="text-sm text-success mt-1">âœ“</span>
           {:else if accessibilityStatus === 'checking'}
             <span class="loading loading-spinner loading-xs mt-1"></span>
           {/if}
        </div>

        <!-- Microphone Permission -->
        <div class="flex items-start gap-4">
          <div class="bg-base-200 p-3 rounded-full mt-1">
            <span class="text-xl">ðŸŽ¤</span>
          </div>
          <div class="flex-1">
            <h4 class="font-semibold">Microphone Access</h4>
            <p class="text-sm opacity-70">Required to capture audio for transcription.</p>
             <div class="flex items-center gap-2 mt-1">
              <span class="badge {getBadgeClass(microphoneStatus)} gap-1">
                 {#if microphoneStatus !== 'checking' && microphoneStatus !== 'unavailable'}
                    <span class="bg-white rounded-full w-2 h-2"></span>
                 {/if}
                 {getStatusText(microphoneStatus)}
              </span>
               {#if microphoneStatus === 'denied' || microphoneStatus === 'restricted'}
                  <p class="text-xs text-error">Please grant access in System Settings.</p>
               {/if}
            </div>
             {#if microphoneStatus === 'not-determined' || microphoneStatus === 'denied' || microphoneStatus === 'restricted'}
                <div class="mt-2">
                    <button class="btn btn-primary btn-sm" on:click={requestMicrophone}>
                      Request Access
                    </button>
                </div>
             {/if}
          </div>
           {#if microphoneStatus === 'granted'}
             <span class="text-sm text-success mt-1">âœ“</span>
           {:else if microphoneStatus === 'checking'}
             <span class="loading loading-spinner loading-xs mt-1"></span>
           {/if}
        </div>

        <!-- Screen Recording Permission -->
         <div class="flex items-start gap-4">
          <div class="bg-base-200 p-3 rounded-full mt-1">
            <span class="text-xl">ðŸ–¥ï¸</span>
          </div>
          <div class="flex-1">
            <h4 class="font-semibold">Screen Recording (macOS)</h4>
            <p class="text-sm opacity-70">Optional - For future contextual features.</p>
             <div class="flex items-center gap-2 mt-1">
              <span class="badge {getBadgeClass(screenRecordingStatus)} gap-1">
                 {#if screenRecordingStatus !== 'checking' && screenRecordingStatus !== 'unavailable'}
                    <span class="bg-white rounded-full w-2 h-2"></span>
                 {/if}
                 {getStatusText(screenRecordingStatus)}
              </span>
               {#if screenRecordingStatus === 'denied' || screenRecordingStatus === 'restricted' || screenRecordingStatus === 'not-granted'}
                  <p class="text-xs text-error">Please grant access in System Settings.</p>
               {/if}
               {#if screenRecordingStatus === 'unavailable'}
                 <p class="text-xs opacity-50">(macOS only feature)</p>
               {/if}
            </div>
             {#if screenRecordingStatus !== 'granted' && screenRecordingStatus !== 'checking' && screenRecordingStatus !== 'unavailable'}
                <div class="mt-2">
                    <button class="btn btn-primary btn-sm" on:click={openScreenRecordingSettings}>
                      Open Settings
                    </button>
                </div>
             {/if}
          </div>
           {#if screenRecordingStatus === 'granted'}
             <span class="text-sm text-success mt-1">âœ“</span>
           {:else if screenRecordingStatus === 'checking'}
             <span class="loading loading-spinner loading-xs mt-1"></span>
           {/if}
        </div>

      </div>

      <div class="bg-base-200 p-4 rounded-md mt-6">
        <h4 class="font-semibold mb-1">Why do we need these permissions?</h4>
        <p class="text-sm opacity-80">
          Accessibility features on macOS are required for global keyboard shortcuts. Microphone access is needed for audio capture. Screen recording is optional for potential future features.
        </p>
        <p class="text-sm opacity-80 mt-2">
          All processing is done locally on your device.
        </p>
      </div>
  </div>
</div>

================
File: components/settings/Shortcuts.svelte
================
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';

  const availableKeys = [
    { id: 'Fn', label: 'Fn', mapped: 'FN' }, // FN key is often problematic for global monitoring
    { id: 'ControlLeft', label: 'Control', mapped: 'CONTROL' }, // Use generic CONTROL
    { id: 'AltLeft', label: 'Option (Alt)', mapped: 'OPTION' },   // Use generic OPTION
    { id: 'MetaLeft', label: 'Command', mapped: 'COMMAND' },    // Use generic COMMAND
  ];

  // --- Component State ---
  let selectedKeyIds: string[] = []; // UI state (using 'id')
  // let saveSuccess = false; // Removed
  let lastAction = { action: '', key: '', time: 0 };
  let isRecording = false; // Local copy of recording state from main process
  let isToggleMode = false; // Local copy of toggle mode state

  // --- API Communication ---
  let cleanupShortcutListener: (() => void) | null = null;
  let cleanupStateListener: (() => void) | null = null;

  // Function to get the mapped key names (COMMAND, OPTION, etc.) from selected IDs
  function getMappedKeys(): string[] {
      return selectedKeyIds
          .map(id => availableKeys.find(k => k.id === id)?.mapped)
          .filter((mapped): mapped is string => !!mapped);
  }

  onMount(async () => {
    window.api.log('info', 'Shortcuts component mounted.');

    // Load stored *mapped* keys
    const storedMappedKeys = await window.api.getStoreValue('shortcutKeysMapped') as string[] | undefined;
    if (storedMappedKeys && Array.isArray(storedMappedKeys)) {
      selectedKeyIds = availableKeys
          .filter(k => storedMappedKeys.includes(k.mapped))
          .map(k => k.id);
      window.api.log('debug', 'Loaded mapped keys from store:', storedMappedKeys);
    } else {
        // Fallback (optional)
        const legacyStoredKeys = await window.api.getStoreValue('shortcutKeys') as string[] | undefined;
         if (legacyStoredKeys && Array.isArray(legacyStoredKeys)) {
             selectedKeyIds = legacyStoredKeys.filter(keyId => availableKeys.some(k => k.id === keyId));
             window.api.log('debug', 'Loaded legacy key IDs from store:', selectedKeyIds);
         }
    }

    // Tell main process to start monitoring the initially loaded keys
    await window.api.updateMonitoredKeys(getMappedKeys());
    window.api.log('info', 'Initial monitored keys sent to main process:', getMappedKeys());

    // Listen for raw shortcut actions (for debugging/UI feedback)
    cleanupShortcutListener = window.api.onShortcutAction((action, keyName) => {
      window.api.log('debug', `Raw Shortcut Action Received: ${action}, Key: ${keyName}`);
      lastAction = { action, key: keyName, time: Date.now() };
      // We don't directly act on these anymore, state comes from recordingStateUpdate
    });

    // Listen for recording state updates from the main process
    cleanupStateListener = window.api.onRecordingStateUpdate((state) => {
        window.api.log('info', 'Recording state update received:', state);
        isRecording = state.isRecording;
        isToggleMode = state.isToggleMode;
    });

    // TODO: Optionally request initial state from main process if needed immediately
    // const initialState = await window.api.getRecordingState(); // Need to add getRecordingState to preload/main
    // if(initialState) {
    //     isRecording = initialState.isRecording;
    //     isToggleMode = initialState.isToggleMode;
    // }
  });

  onDestroy(() => {
    window.api.log('info', 'Shortcuts component destroying, cleaning up listeners.');
    if (cleanupShortcutListener) cleanupShortcutListener();
    if (cleanupStateListener) cleanupStateListener();
    // Consider if main process should stop monitoring here or on app quit
  });

  // Debounce function for saving/updating keys
  let saveTimeout: NodeJS.Timeout | null = null;
  const updateKeys = (keys: string[]) => {
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(async () => {
          const mappedKeysToSave = getMappedKeys(); // Recalculate mapped keys based on current selection
          window.api.log('info', 'Auto-saving shortcut keys:', mappedKeysToSave);
          try {
              await window.api.setStoreValue('shortcutKeysMapped', mappedKeysToSave);
              await window.api.updateMonitoredKeys(mappedKeysToSave);
              window.api.log('info', 'Shortcut keys auto-saved and monitoring updated.');
          } catch (error) {
               window.api.log('error', 'Failed to auto-save shortcut keys:', error);
          }
      }, 500); // Debounce 500ms
  };

  // Reactive statement to trigger update when selection changes
  $: if (selectedKeyIds) {
      // Need to ensure this runs *after* initial load from store in onMount
      // A simple check or a dedicated 'isLoaded' flag could work, but
      // debouncing might be sufficient if onMount finishes quickly.
      // Let's rely on debouncing for now.
      updateKeys(selectedKeyIds);
  }

</script>

<div class="p-4">
  <h2 class="text-2xl font-bold mb-6">Keyboard Shortcuts</h2>

  <div class="bg-base-100 max-w-xl">
      <p class="text-sm opacity-70 mb-4">
        Select modifier keys to control recording.
      </p>
      <ul class="text-sm opacity-70 mb-4 list-disc pl-5">
        <li><strong>Hold:</strong> Record while key is held down.</li>
        <li><strong>Double Click:</strong> Toggle recording on/off.</li>
        <li>Clicks get dismissed.</li>
      </ul>

      <div class="form-control space-y-2 flex flex-col">
        {#each availableKeys as key}
          <label class="label cursor-pointer justify-start gap-4">
            <input
              type="checkbox"
              bind:group={selectedKeyIds}
              value={key.id}
              class="checkbox checkbox-primary"
            />
            <span class="label-text">{key.label}</span>
          </label>
        {/each}
      </div>

      <!-- Removed Save Success Alert -->

      <!-- Optional: Display last raw action for debugging -->
       {#if lastAction.time > 0}
         <p class="text-xs opacity-50 mt-4">Last Raw Action: {lastAction.action} on {lastAction.key} at {new Date(lastAction.time).toLocaleTimeString()}</p>
       {/if}

    </div>
</div>

================
File: components/settings/Transcription.svelte
================
<script lang="ts">
  import { onMount } from "svelte";
  import { writable, get } from "svelte/store";

  const openaiApiKey = writable("");
  const openaiModel = writable<"gpt-4o-mini-transcribe" | "gpt-4o-transcribe">(
    "gpt-4o-mini-transcribe",
  );
  const provider = writable<"openai" | "deepgram">("openai");
  const deepgramApiKey = writable("");
  const deepgramModel = writable<"nova-3" | "enhanced" | "whisper-large">(
    "nova-3",
  );

  let isLoading = true;

  onMount(async () => {
    try {
      const initialSettingsPromise = window.api.getStoreValue(
        "transcription",
      ) as Promise<any | undefined>;

      const [initialSettings] = await Promise.all([
        initialSettingsPromise,
      ]);

      const currentProvider = initialSettings.provider;
      if (currentProvider === 'openai' || currentProvider === 'deepgram') {
          provider.set(currentProvider);
      } else {
          provider.set('deepgram');
          window.api.log('warn', `Invalid or local provider "${currentProvider}" found in settings, defaulting to deepgram.`);
      }

      openaiApiKey.set(initialSettings.openaiApiKey || "");
      openaiModel.set(initialSettings.openaiModel || "gpt-4o-mini-transcribe");
      deepgramApiKey.set(initialSettings.deepgramApiKey || "");
      deepgramModel.set(initialSettings.deepgramModel || "nova-3");
    } catch (error) {
      window.api.log("error", "Failed to load transcription settings:", error);
    } finally {
      isLoading = false;
    }
  });

  let saveTimeout: NodeJS.Timeout | null = null;
  const saveSettings = () => {
    if (isLoading) return;
    if (saveTimeout) clearTimeout(saveTimeout);

    const currentSettings = {
      provider: get(provider),
      openaiApiKey: get(openaiApiKey),
      openaiModel: get(openaiModel),
      deepgramApiKey: get(deepgramApiKey),
      deepgramModel: get(deepgramModel),
    };

    saveTimeout = setTimeout(async () => {
      try {
        await window.api.setStoreValue("transcription", currentSettings);
        window.api.log("info", "Transcription settings auto-saved.");
      } catch (error) {
        window.api.log(
          "error",
          "Failed to auto-save transcription settings:",
          error,
        );
      }
    }, 500);
  };

  $: if (!isLoading) {
    const currentProviderValue = $provider;
    const currentApiKeyValue = $openaiApiKey;
    const currentModelValue = $openaiModel;
    const currentDeepgramApiKeyValue = $deepgramApiKey;
    const currentDeepgramModelValue = $deepgramModel;

    saveSettings();
  }
</script>

<div class="p-4 space-y-6">
  <h2 class="text-xl font-semibold">Transcription Settings</h2>

  {#if isLoading}
    <p>Loading settings...</p>
  {:else}
    <div class="space-y-4">
      <!-- Provider Selection -->
      <div class="form-control">
        <label class="label" for="provider-select">
          <span class="label-text">Transcription Provider</span>
        </label>
        <select
          id="provider-select"
          class="select select-bordered w-full max-w-xs"
          bind:value={$provider}
        >
          <option value="openai">OpenAI Whisper API</option>
          <option value="deepgram">Deepgram API</option>
        </select>
      </div>

      {#if $provider === "openai"}
        <div class="form-control">
          <label class="label" for="openai-api-key">
            <span class="label-text">OpenAI API Key (for Transcription)</span>
          </label>
          <input
            id="openai-api-key"
            type="password"
            placeholder="sk-..."
            class="input input-bordered w-full"
            bind:value={$openaiApiKey}
          />
          <label class="label">
            <span class="label-text-alt"
              >Required for OpenAI transcription. Get key from <a
                href="https://platform.openai.com/api-keys"
                target="_blank"
                class="link link-primary">OpenAI Platform</a
              >.</span
            >
          </label>
        </div>

        <div class="form-control">
          <label class="label" for="openai-model-select">
            <span class="label-text">OpenAI Whisper Model</span>
          </label>
          <select
            id="openai-model-select"
            class="select select-bordered w-full max-w-xs"
            bind:value={$openaiModel}
          >
            <option value="gpt-4o-mini-transcribe"
              >GPT-4o Mini Transcribe</option
            >
            <option value="gpt-4o-transcribe">GPT-4o Transcribe</option>
          </select>
          <label class="label">
            <span class="label-text-alt">Select the Whisper model to use.</span>
          </label>
        </div>
      {/if}

      {#if $provider === "deepgram"}
        <div class="form-control">
          <label class="label" for="deepgram-api-key">
            <span class="label-text">Deepgram API Key</span>
          </label>
          <input
            id="deepgram-api-key"
            type="password"
            placeholder="..."
            class="input input-bordered w-full"
            bind:value={$deepgramApiKey}
          />
          <label class="label">
            <span class="label-text-alt"
              >Required for Deepgram transcription. Get key from <a
                href="https://console.deepgram.com/signup"
                target="_blank"
                class="link link-primary">Deepgram Console</a
              >.</span
            >
          </label>
        </div>

        <div class="form-control">
          <label class="label" for="deepgram-model-select">
            <span class="label-text">Deepgram Model</span>
          </label>
          <select
            id="deepgram-model-select"
            class="select select-bordered w-full max-w-xs"
            bind:value={$deepgramModel}
          >
            <option value="nova-3">Nova 3 (Best)</option>
            <option value="enhanced">Enhanced</option>
            <option value="whisper-large">Whisper Large</option>
          </select>
          <label class="label">
            <span class="label-text-alt">Select the Deepgram model to use.</span
            >
          </label>
        </div>
      {/if}
    </div>
  {/if}
</div>

================
File: components/WaterWaveAnimation.svelte
================
<script lang="ts">
  type Status = 'idle' | 'recording' | 'processing';

  export let status: Status = 'idle';
  export let size: string = '3rem';
  export let idleBorderColor: string = 'rgba(148, 163, 184, 0.3)';
  export let activeColor: string = '#33cfff';
  export let spinnerBorderWidth: string = '3px';
  export let waveDuration1: string = '4s';
  export let waveDuration2: string = '6s';
  export let waveDuration3: string = '10s';

  $: waveAnimationState = status === 'recording' ? 'running' : 'paused';

  $: containerStyle = `
    --size: ${size};
    --idle-border-color: ${idleBorderColor};
    --active-color: ${activeColor};
    --spinner-border-width: ${spinnerBorderWidth};
    --wave-anim-duration-1: ${waveDuration1};
    --wave-anim-duration-2: ${waveDuration2};
    --wave-anim-duration-3: ${waveDuration3};
  `;

</script>

<div
  class="status-indicator-container {status}"
  style={containerStyle}
  role="status"
  aria-live="polite"
  aria-label={status === 'processing' ? 'Processing' : (status === 'recording' ? 'Recording active' : 'Idle')}
>
  <div class="water-wave water-wave1" style="animation-play-state: {waveAnimationState};"></div>
  <div class="water-wave water-wave2" style="animation-play-state: {waveAnimationState};"></div>
  <div class="water-wave water-wave3" style="animation-play-state: {waveAnimationState};"></div>
</div>

<style>
  .status-indicator-container {
    position: relative;
    width: var(--size);
    height: var(--size);
    border-radius: 50%;
    box-sizing: border-box;
    overflow: hidden;
    border: var(--spinner-border-width) solid transparent;
    transition: border-color 0.3s ease-in-out;
  }

  .status-indicator-container.idle {
    border-color: var(--idle-border-color);
  }
  .status-indicator-container.idle .water-wave {
    opacity: 0.6;
    transform: scale(1);
  }

  .status-indicator-container.recording {
    border-color: var(--idle-border-color);
  }
  .status-indicator-container.recording .water-wave {
    opacity: 1;
    transform: scale(1);
  }

  .status-indicator-container.processing {
    border-color: color-mix(in srgb, var(--active-color) 15%, transparent);
    border-left-color: var(--active-color);
    animation: spin 1s linear infinite;
  }
  .status-indicator-container.processing .water-wave {
    opacity: 0;
    transform: scale(0.8);
  }

  .water-wave {
    position: absolute;
    width: 200%;
    height: 200%;
    border-radius: 40%;
    background-color: var(--active-color);
    animation-name: water-waves;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
    opacity: 0;
    transform: scale(1);
    transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
    animation-play-state: paused;
  }

  .water-wave1 {
    top: 40%;
    left: -25%;
    opacity: 0.7;
    border-radius: 40%;
    animation-duration: var(--wave-anim-duration-1);
  }

  .water-wave2 {
    top: 45%;
    left: -35%;
    opacity: 0.5;
    border-radius: 35%;
    animation-duration: var(--wave-anim-duration-2);
  }

  .water-wave3 {
    top: 50%;
    left: -35%;
    opacity: 0.3;
    border-radius: 33%;
    animation-duration: var(--wave-anim-duration-3);
  }

  @keyframes water-waves {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
</style>

================
File: lib/audioRecorder.ts
================
import { writable } from 'svelte/store';

export const recordingStatus = writable<'idle' | 'recording' | 'processing' | 'error'>('idle');
export const transcriptionResult = writable<string | null>(null);
export const transcriptionError = writable<string | null>(null);

let mediaRecorder: MediaRecorder | null = null;
let cancelRequested = false;
let audioChunks: Blob[] = [];
let audioStream: MediaStream | null = null;
let audioContext: AudioContext | null = null;

const SILENCE_THRESHOLD = 0.07;
const DESIRED_AUDIO_BITRATE = 32000;

export function initializeAudioRecorder(): () => void {
  window.api.log('info', 'Initializing audio recorder listeners...');

  const cleanupStart = window.api.onStartRecording(() => {
    cancelRequested = false;
    startRecording();
  });
  const cleanupStop = window.api.onStopRecording(() => {
    stopRecording();
  });
  const cleanupCancel = window.api.onCancelRecording(() => {
      window.api.log('info', 'Cancel recording requested (IPC). Setting flag and forcing cleanup.');
      cancelRequested = true;
      const recorderToStop = mediaRecorder;
      const streamToStop = audioStream;
      mediaRecorder = null;
      audioStream = null;
      audioChunks = [];
      streamToStop?.getTracks().forEach(track => {
          try { track.stop(); } catch (e) { window.api.log('warn', 'Error stopping audio track during cancel:', e); }
      });
      window.api.log('debug', 'Skipping mediaRecorder.stop() during forced cancel.');
  });
  const cleanupResult = window.api.onTranscriptionResult(handleTranscriptionResult);
  const cleanupError = window.api.onTranscriptionError(handleTranscriptionError);
  const cleanupStatus = window.api.onRecordingStatus(handleRecordingStatus);

  return () => {
    window.api.log('info', 'Cleaning up audio recorder listeners...');
    cleanupStart();
    cleanupStop();
    cleanupCancel();
    cleanupResult();
    cleanupError();
    cleanupStatus();
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      try { mediaRecorder.stop(); } catch(e) {}
    }
    if (audioStream) {
      audioStream.getTracks().forEach(track => { try {track.stop();} catch(e) {} });
    }
    if (audioContext && audioContext.state !== 'closed') {
        audioContext.close().catch(e => window.api.log('warn', 'Error closing AudioContext on cleanup:', e));
        audioContext = null;
    }
    cancelRequested = false;
  };
}

async function startRecording(): Promise<void> {
  window.api.log('info', 'Start recording requested...');
  cancelRequested = false;
  transcriptionResult.set(null);
  transcriptionError.set(null);

  if (mediaRecorder) {
    window.api.log('warn', `Start request ignored. Recorder instance already exists (state: ${mediaRecorder?.state}).`);
    return;
  }
  if (cancelRequested) {
     window.api.log('warn', 'Start request ignored. Cancel flag already set.');
     return;
  }

  let obtainedStream: MediaStream | null = null;

  try {
    obtainedStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    if (cancelRequested) {
        window.api.log('warn', 'Recording cancelled after getUserMedia was granted. Cleaning up stream.');
        obtainedStream?.getTracks().forEach(track => track.stop());
        return;
    }
    audioStream = obtainedStream;
    window.api.log('info', 'Microphone access granted.');

    const options = getSupportedMimeTypeAndOptions();
    window.api.log('info', `Using MediaRecorder options: ${JSON.stringify(options)}`);

    if (cancelRequested) {
        window.api.log('warn', 'Recording cancelled before creating MediaRecorder.');
        audioStream?.getTracks().forEach(track => track.stop());
        audioStream = null;
        return;
    }

    const localRecorder = new MediaRecorder(audioStream, options);
    mediaRecorder = localRecorder;
    audioChunks = [];

    localRecorder.ondataavailable = (event) => {
      if (cancelRequested) {
          return;
      }
      if (event.data.size > 0) {
        audioChunks.push(event.data);
      }
    };

    localRecorder.onstop = async () => {
      const currentRecorderRef = mediaRecorder;
      const currentMimeType = currentRecorderRef?.mimeType || options.mimeType || 'audio/webm';
      window.api.log('info', `MediaRecorder stopped. Cancelled flag: ${cancelRequested}`);

      if (cancelRequested) {
          window.api.log('info', 'Recording cancelled (detected in onstop), discarding audio data.');
          cleanupAfterRecording(true);
          return;
      }

      if (audioChunks.length === 0) {
          window.api.log('warn', 'No audio data recorded (or cleared due to cancel).');
          cleanupAfterRecording(false);
          return;
      }

      const audioBlob = new Blob(audioChunks, { type: currentMimeType });
      window.api.log('info', `Combined audio blob size: ${audioBlob.size} bytes, type: ${audioBlob.type}`);

      let processingError = null;
      try {
        const arrayBuffer = await audioBlob.arrayBuffer();

        if (cancelRequested) {
            window.api.log('warn', 'Recording cancelled before audio processing/sending.');
            throw new Error("Cancelled before processing");
        }

        if (!audioContext || audioContext.state === 'closed') {
            try {
                 audioContext = new AudioContext();
            } catch (acError) {
                window.api.log('warn', 'Could not create AudioContext, falling back to default.', acError);
                audioContext = new AudioContext();
            }
        }

        let audioBuffer: AudioBuffer;
        try {
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
        } catch (decodeError) {
             window.api.log('error', 'Audio decode failed:', decodeError);
             throw new Error(`Audio decode failed: ${decodeError.message}`);
        }

        window.api.log('info', `Audio decoded: Duration=${audioBuffer.duration.toFixed(2)}s, SampleRate=${audioBuffer.sampleRate}Hz`);

        if (isAudioSilent(audioBuffer)) {
            window.api.log('info', 'Detected silence, skipping transcription. Notifying main process.');
            window.api.notifySilenceCancellation();
            throw new Error("Silent audio detected");
        }

         if (cancelRequested) {
            window.api.log('warn', 'Recording cancelled just before sending to main process.');
            throw new Error("Cancelled before sending");
        }

        const audioPayload = { audioData: arrayBuffer, mimeType: currentMimeType };
        window.api.log('info', `Sending audio (${(arrayBuffer.byteLength / 1024).toFixed(1)} KB) for transcription...`);
        await window.api.transcribeAudio(audioPayload);
        window.api.log('info', 'Audio data sent to main process.');

      } catch (error) {
        if (error.message.startsWith("Cancelled") || error.message.startsWith("Silent")) {
            window.api.log('info', `Processing skipped due to: ${error.message}`);
        } else {
            window.api.log('error', 'Error during audio processing or sending:', error);
            processingError = error;
        }
      } finally {
          cleanupAfterRecording(cancelRequested || (processingError && processingError.message.startsWith("Cancelled")));
          if (processingError && !processingError.message.startsWith("Cancelled") && !processingError.message.startsWith("Silent")) {
              handleTranscriptionError(`Processing error: ${processingError.message || processingError}`);
          }
      }
    };

    localRecorder.onerror = (event) => {
       window.api.log('error', 'MediaRecorder error:', (event as ErrorEvent).error || event);
       handleTranscriptionError(`Recording error: ${(event as ErrorEvent).error?.message || 'Unknown recording error'}`);
       cleanupAfterRecording(cancelRequested);
    };

    if (cancelRequested) {
         window.api.log('warn', 'Recording cancelled just before MediaRecorder.start().');
         cleanupAfterRecording(true);
         return;
    }

    try {
        localRecorder.start();
        window.api.log('info', `MediaRecorder started (Bitrate: ${localRecorder.audioBitsPerSecond || 'default'}, MimeType: ${localRecorder.mimeType}).`);
        window.api.notifyRecorderStarted();
    } catch (startError) {
         window.api.log('error', 'Error calling MediaRecorder.start():', startError);
         handleTranscriptionError(`Failed to start recorder: ${startError.message}`);
         cleanupAfterRecording(false);
    }

  } catch (err) {
     window.api.log('error', 'Error accessing microphone or starting recorder:', err);
     let errorMessage = 'Unknown error';
     if (err instanceof Error) {
         errorMessage = err.message;
         if (err.name === 'NotAllowedError') {
             errorMessage = 'Microphone permission denied.';
         } else if (err.name === 'NotFoundError') {
             errorMessage = 'No microphone found.';
         } else if (err.name === 'NotReadableError') {
             errorMessage = 'Microphone is already in use or hardware error.';
         }
     }
     handleTranscriptionError(`Microphone access error: ${errorMessage}`);
     if (obtainedStream) {
        obtainedStream.getTracks().forEach(track => track.stop());
     }
     audioStream = null;
     mediaRecorder = null;
  }
}

function cleanupAfterRecording(isCancellationOrSilence: boolean): void {
    window.api.log('debug', `Cleaning up audio resources (Is Cancellation/Silence: ${isCancellationOrSilence})`);
    audioStream?.getTracks().forEach(track => {
        try { track.stop(); } catch(e) { window.api.log('warn', 'Error stopping track in cleanup:', e); }
    });
    audioStream = null;
    mediaRecorder = null;
    audioChunks = [];
    window.api.log('debug', `Cleanup done, cancelRequested flag state preserved: ${cancelRequested}`);
}

export function stopRecording(): void {
  window.api.log('info', `Stop recording requested. Current state: ${mediaRecorder?.state}. Cancelled: ${cancelRequested}`);
  if (cancelRequested) {
      window.api.log('warn', 'Stop ignored because cancelRequested is true.');
      cleanupAfterRecording(true);
      return;
  }
  const recorder = mediaRecorder;
  if (recorder && recorder.state === 'recording') {
    try {
        recorder.stop();
    } catch (e) {
        window.api.log('error', 'Error calling MediaRecorder.stop():', e);
        handleTranscriptionError(`Failed to stop recorder: ${e instanceof Error ? e.message : String(e)}`);
        cleanupAfterRecording(false);
    }
  } else if (recorder && recorder.state === 'inactive') {
      window.api.log('warn', 'Stop requested but recorder is already inactive. Cleaning up.');
      cleanupAfterRecording(false);
  } else {
     window.api.log('warn', `Stop requested but no active/inactive recorder found or state is ${recorder?.state}.`);
     cleanupAfterRecording(false);
  }
}

function handleTranscriptionResult(text: string): void {
  window.api.log('info', `Transcription result received: "${text}"`);
  transcriptionResult.set(text);
  transcriptionError.set(null);
}

function handleTranscriptionError(error: string): void {
  window.api.log('error', `Transcription/Processing error received: ${error}`);
  transcriptionError.set(error);
  transcriptionResult.set(null);
}

function handleRecordingStatus(status: 'idle' | 'recording' | 'processing' | 'error'): void {
   window.api.log('debug', `[Renderer/audioRecorder] handleRecordingStatus received status from main: ${status}`);
   recordingStatus.set(status);
}

function getSupportedMimeTypeAndOptions(): MediaRecorderOptions {
    const types = [
        'audio/webm;codecs=opus',
        'audio/ogg;codecs=opus',
        'audio/webm;codecs=vp8',
        'audio/webm',
        'audio/ogg',
    ];

    let supportedMimeType = '';
    for (const type of types) {
        if (MediaRecorder.isTypeSupported(type)) {
            supportedMimeType = type;
            break;
        }
    }

    if (!supportedMimeType) {
         window.api.log('warn', 'No preferred MIME type supported, using browser default.');
    }

    const options: MediaRecorderOptions = {};
    if (supportedMimeType) {
        options.mimeType = supportedMimeType;
    }
    options.audioBitsPerSecond = DESIRED_AUDIO_BITRATE;

    return options;
}

function isAudioSilent(audioBuffer: AudioBuffer): boolean {
    const channelCount = audioBuffer.numberOfChannels;
    const threshold = SILENCE_THRESHOLD;
    let maxAmplitude = 0;

    for (let i = 0; i < channelCount; i++) {
        const channelData = audioBuffer.getChannelData(i);
        for (let j = 0; j < channelData.length; j++) {
            const amplitude = Math.abs(channelData[j]);
            if (amplitude > maxAmplitude) {
                 maxAmplitude = amplitude;
                 if (maxAmplitude > threshold) {
                     window.api.log('debug', `Detected amplitude ${maxAmplitude.toFixed(4)} > threshold ${threshold}. Not silent.`);
                     return false;
                 }
            }
        }
    }
    window.api.log('debug', `Max detected amplitude: ${maxAmplitude.toFixed(4)} (Threshold: ${threshold}). Silent.`);
    return maxAmplitude <= threshold;
}

export function get<T>(store: { subscribe: (cb: (value: T) => void) => () => void }): T {
  let value: T;
  const unsubscribe = store.subscribe(v => value = v);
  unsubscribe();
  return value;
}

================
File: App.svelte
================
<script lang="ts">
  import { onMount, onDestroy } from "svelte";
  import AppLayout from "./components/layout/AppLayout.svelte";
  import Dashboard from "./components/settings/Dashboard.svelte";
  import Logs from "./components/settings/Logs.svelte";
  import Dictionary from "./components/settings/Dictionary.svelte";
  import History from "./components/settings/History.svelte";
  import Enhancements from "./components/settings/Enhancements.svelte";
  import Permissions from "./components/settings/Permissions.svelte";
  import Shortcuts from "./components/settings/Shortcuts.svelte";
  import Transcription from "./components/settings/Transcription.svelte";
  import { initializeAudioRecorder } from "./lib/audioRecorder";

  let activePage = "dashboard";

  let cleanupAudioRecorder: (() => void) | null = null;

  onMount(() => {
    cleanupAudioRecorder = initializeAudioRecorder();
  });

  onDestroy(() => {
    if (cleanupAudioRecorder) {
      cleanupAudioRecorder();
    }
  });
</script>

<AppLayout bind:activePage>
  {#if activePage === "dashboard"}
    <Dashboard />
  {:else if activePage === "shortcuts"}
    <Shortcuts />
  {:else if activePage === "transcription"}
    <Transcription />
  {:else if activePage === "enhancements"}
    <Enhancements />
  {:else if activePage === "dictionary"}
    <Dictionary />
  {:else if activePage === "permissions"}
    <Permissions />
  {:else if activePage === "history"}
    <History />
  {:else if activePage === "logs"}
    <Logs />
  {/if}
</AppLayout>

================
File: env.d.ts
================
/// <reference types="svelte" />
/// <reference types="vite/client" />

================
File: main.ts
================
import { mount } from 'svelte'

import './assets/main.css'

import App from './App.svelte'

const app = mount(App, {
  target: document.getElementById('app')!
})

export default app

================
File: widget.ts
================
import WidgetApp from './WidgetApp.svelte';
import { mount } from 'svelte';

import './assets/widget.css'

const app = mount(WidgetApp, { target: document.getElementById("widget-root") });

================
File: WidgetApp.svelte
================
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { writable } from 'svelte/store';
  import { fade } from 'svelte/transition';
  import WaterWaveAnimation from './components/WaterWaveAnimation.svelte';

  type OverallStatus = 'idle' | 'recording' | 'processing' | 'error';
  type WidgetDisplayState = 'idle' | 'initializing' | 'recording' | 'processing' | 'error';

  const widgetDisplayState = writable<WidgetDisplayState>('idle');
  let currentDisplayState: WidgetDisplayState = 'idle';

  let recorderActuallyStarted = false;
  let currentOverallStatus: OverallStatus = 'idle';

  let visible = false;
  let elapsedTime = 0;
  let timer: NodeJS.Timeout | undefined = undefined;

  let cleanupStatusListener: (() => void) | null = null;
  let cleanupRecorderStartedListener: (() => void) | null = null;

  function startTimer() {
    stopTimer();
    timer = setInterval(() => {
      elapsedTime += 1;
    }, 1000);
  }

  function stopTimer() {
    if (timer) {
      clearInterval(timer);
      timer = undefined;
      elapsedTime = 0;
    }
  }

  function formatTime(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  }

  onMount(() => {
    const unsubscribeDisplayState = widgetDisplayState.subscribe((newState) => {
      currentDisplayState = newState;
      visible = ['recording', 'processing'].includes(newState);
    });

    cleanupStatusListener = window.widgetApi.onStatusUpdate((newStatus: OverallStatus) => {
      currentOverallStatus = newStatus;

      switch (newStatus) {
        case 'recording':
          if (!recorderActuallyStarted) {
            widgetDisplayState.set('initializing');
            if (timer) stopTimer();
          } else {
            widgetDisplayState.set('recording');
            if (!timer) startTimer();
          }
          break;
        case 'processing':
          stopTimer();
          recorderActuallyStarted = false;
          widgetDisplayState.set('processing');
          break;
        case 'idle':
        case 'error':
          stopTimer();
          recorderActuallyStarted = false;
          widgetDisplayState.set(newStatus === 'error' ? 'error' : 'idle');
          break;
      }
    });

    cleanupRecorderStartedListener = window.widgetApi.onRecorderStarted(() => {
      recorderActuallyStarted = true;
      if (currentOverallStatus === 'recording') {
        widgetDisplayState.set('recording');
        startTimer();
      }
    });

    return () => {
      stopTimer();
      unsubscribeDisplayState();
      cleanupStatusListener?.();
      cleanupRecorderStartedListener?.();
    };
  });

  onDestroy(() => {
    stopTimer();
  });
</script>

{#if visible}
<div
  class="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-50"
  transition:fade={{ duration: 150 }}
>
  <div class="flex items-center bg-black/85 backdrop-blur-md rounded-full py-1.5 px-4 shadow-lg border border-gray-600/30 gap-2">
    <div>
      <WaterWaveAnimation
        status={currentDisplayState === 'error' ? 'idle' : currentDisplayState}
        size="1.5rem"
        borderColor="rgba(148, 163, 184, 0.3)"
      />
    </div>

    <div class="text-xs text-gray-200 font-medium w-20 text-center flex items-center justify-center h-[1.5rem]">
      {#if currentDisplayState === 'recording'}
        <span class="tabular-nums">{formatTime(elapsedTime)}</span>
      {:else if currentDisplayState === 'processing'}
        <div class="flex space-x-1 justify-center items-center">
          <span class="sr-only">Loading...</span>
          <div class='h-1 w-1 bg-gray-300 rounded-full animate-bounce [animation-delay:-0.3s]'></div>
          <div class='h-1 w-1 bg-gray-300 rounded-full animate-bounce [animation-delay:-0.15s]'></div>
          <div class='h-1 w-1 bg-gray-300 rounded-full animate-bounce'></div>
        </div>
      {:else if currentDisplayState === 'error'}
        Error
      {/if}
    </div>
  </div>
</div>
{/if}



================================================================
End of Codebase
================================================================
